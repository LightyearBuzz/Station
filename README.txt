/*Игра Station, написана 14.11.2018
*В ней используется: 
*1.язык С++
*2.объектно-ориентированный подход программирования
*3.шаблон проектирования MVC
*4.алгоритм построения лабиринтов Recursive Backtracker
*
*Место действие игры Station - космический корабль пришельцев, который потерпел крушение.
*При запуске игры пользвателю предлогается указать размеры корабля, корабль это прямоугольный
*лабиринт в котором игроку нужно найти компьютер пришельцев и получить описание гравитационной 
*технологии которая храниться в его памяти. Для доступа к компьютеру нужен электронный ключ, 
*корорый необходимо найти.
*
*
*Программа интересна тем, что при запуске не знает какого размера корабль нужно спроектировать, 
*размеры корабля вводит пользователь. Это означает, что помещение проектируется в момент выполнения,
*а не заранее. Для этого программа динамически выделяет память, и проектирует в ней лабиринт, затем 
*расставляет по лабиринту предметы.
*
*
*                   Устройство шаблона MVC
*Идея шаблона заключается в том, что мы разделяем весь код на 3 логических блока(Model View Controller).
*У каждого блока своое назначение, а главная особенность в том, что любой из них можно легко заменить
*или модифицировать, при этом, практически не касаясь других подсистем. Мы получаем такие преимущества 
*как модульность, расширяемость, простота поддержки и тестирования.
*
*Первый блок - Model 
*Модель отвечает за алгоритмы, расчёты, содержит основную "механику" приложения.
*
*Второй блок - View
*Отвечает за отображение информации. Он содежит все команды вывода текста на консоль.
*
*Третий блок - Controller
*Контроллер принимает команды от пользователя и передает их в модель на обработку
*
*Шаблон MVC подразумевает что блок View следит за состоянием блока Model и при
*изменении состояния выводит на консоль информацию об изменениях. Для реализации этой системы
*мы применим шаблон «Наблюдатель» (Observer).
*
*                 Устройство шаблона Observer
*Идея шаблона "Наблюдатель" заключается в том, что есть два блока кода "Наблюдатель"(Observer)
*и "Наблюдаемое" (Observable), один блок следит за изменениями во втором блоке и реагирует на них.
*Реализовано это так: блок Observable содержит метод notifyUpdate() который в случае изменения 
*состояния Observable вызывает метод Update() в блоке Observer, создается эффект наблюдения 
*Observer за Observable. В реальности же Observable оповещает Observer об изменениях
*
*В нашем случае мы наследуем класс View от класса Observer, и наследуем класс Model от
*класса Observable. Таким образом Model будет оповещать View об изменении своего состояния.
*
*код оформлен в стиле похожем на Google C++ Style
*/